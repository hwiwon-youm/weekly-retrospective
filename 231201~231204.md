# 기술 리포트
## 12월 1일 
### 코드 리뷰에서 나온 질문
- DRF에서 Exception을 어떤 식으로 다루는 게 바람직한지 안다.
- exception이 어떻게 처리되는지 아는가를 먼저 질문해 보아야하지 않을까
- 올바른 예외 처리 방식이 뭔지 안다.
- 왜 if else를 쓰지 않고 try except(catch)를 쓰는가? 이 질문에 대한 답변을 할 수 있으면 안다고 할 수 있을 거 같음
- 고대의 언어에서 함수들은 에러가 나면 return으로 -1을 반환한다든지, 0을 반환한다든지 하는 방법들을 썼음. 그래서 리턴값 검사해서 다음 코드를 짜는 식으로… 
- drf 레벨에서 exception이 발생하면 400이나 500대 status를 가지는 resonse 가 생성된다는 것을 파악하는 것이 출발점인 것 같아 위와 같이 의견을 드렸습니다.

### 올바른 예외처리 방식이란?
예외(exception): 프로그램의 제어 흐름을 바꿀 수 있는 이벤트
파이썬에서는 오류가 발생하면 예외가 자동으로 발생하며, 사용자가 작성한 코드에 의해 발생하고 인터셉트 될 수 있다.

- 어째서 예외를 사용해야 하는가?
  예외는 임의의 프로그램 코드 영역을 벗어나 분기할 수 있도록 한다.
  다음에 진행되야할 코드들을 실행하지 않고 즉시 예외 처리기로 이동할 수 있다. 예외 처리기 안의 코드는 발생한 예외를 적절하게 처리한다.
  예외를 일종의 구조화된 '슈퍼 go to'로 생각해도 ok, 예외 처리기(try문)는 표식을 남기고, 예외 처리 코드를 실행한다.
  예외 발생하면 남겨진 표식 뒤에 호출된 모든 활설화된 함수를 취소하고 표식으로 되돌아간다.
  장점: 처리기 문으로 즉시 분기 하기 때문에 코드가 단순해진다.시래할 가능성이 있는 함수를 호출할때마다 상태값을 확인할 필요가 없다.

- 오류 확인
  파이썬과 예외를 지원하지 않는 언어의 코딩스타일을 비교해보자.
  C언어로 프로그램을 작성하면 오류가 발생할 수 있는 모든 동작에 대해 그 반환값이나 상태 코드를 점검하고, 프로그램의 실행과정에서 그 결과를 전달해야 한다.
  ```
  doStuff()
  {
    if (doFirstThing() == ERROR)
      return ERROR;
    if (doSecondThing() == ERROR)
      return ERROR;
    ...
    return doLastThing();  
  }

  main()
  {
     if (doStuff() == ERROR)
       badEnding();
     else
     goodEnding()
  }
  ```
  실제 C프로그램은 종종 실제 동작에 사용되는 만큼이나 많은 오류 탐지 코드를 가진다. 하지만 파이썬에서는 그렇게 꼼꼼하게 또 강박적으로 작성할 필요가 없다.
  대부분의 코드를 예외 처리기로 감싸고, 모든 것이 정상적으로 동작한다는 가정하에 실제 동작을 하는 부분만을 작성하면 된다.
  예외가 발생하면 제어가 예외처리기로 분기하기 때문에 모든 코드에 오류를 위한 보호막을 칠 필요도 없고, 오류에 대한 테스트로 인한 추가적인 오버헤드도 없다.

- 에러 로깅
  ```
  except Exception as e:
    logging.exception(e)
  ```
  고객에게 unknown error에 대한 메시지를 api 응답으로 보내주는 경우에는 원래 에러가 뭐였는지를 로깅해야 한다.
  로깅을 하지 않으면 정확한 에러가 뭔지 알아서 고객에게 내보내는 경우는 괜찮지만, 그렇지 않은 경우 에러를 묻어버리게 되서 고객은 에러 메시지를 받지만 우리는 에러 발생을 모르게 된다.
  zen of python에도 나오는 `Errors should never pass silently.`  이 문구가 위의 의미라고 볼 수 있다.

참고. 러닝파이썬 하권 p.1361 예외 기초


### htop
htop은 상호작용 시스템 모니터 프로세스 뷰어이자 프로세스 관리자이다. 유닉스 프로그램 top의 대안으로 설계되었다.
<img width="712" alt="image" src="https://github.com/hwiwon-youm/weekly-retrospective/assets/114970648/92393321-6bce-4fd6-a137-1fcb19964ae8">
- CPU 상태: cpu 코어를 프로세스가 점유하는 비율
  - 파랑: low-priority
  - 초록: normal
  - 빨강: kernel(핵심)
  - 하늘: virtualiz(가상화)
- 시스템 전체 메모리 사용률
  - Memory and swap: 전체 메모리의 사용된 메모리양
  - Memory
    - 초록: 사용됨
    - 파랑: 버퍼
    - 노랑: 캐시
  - Swap: 시스템 메모리가 부족할 때 솔리드 스테이트 드라이브 또는 하드 디스크에 임시 저장 공간을 생성하는 시스템 파일
    - 빨강: 사용됨
- Load Average(평균 부하율)
  - 순서대로 1분 평균, 5분 평균, 15분 평균 평균 수치
  - 각 필드의 최대치는 cpu 코어 개수이다. ex. 싱글코어 1.0이면, cpu 전체 부하율이 100%
  - 최대치를 넘는 경우는 불특정 프로세스가 cpu를 점유하기 위해 대기 중인 경우
- 프로세스 리스트
  - PID: 프로세스 식별자(ID)
  - USER: 프로세스의 소유자
  - PR: 프로세스의 우선 순위
  - NI: 우선순위에 영향을 주는 프로세스의 nice 값
  - VIRT: 프로세스가 사용 중인 가상 메모리 양
  - RES: 프로세스가 사용 중인 물리 RAM 의 양 (단위: kb)
  - SHR: 프로세스가 사용 중인 공유 메모리 양
  - S: 프로세스의 현재 상태
    - R: running
    - S: sleeping
    - T: traced / stopped
    - Z: zombie
    - D disk sleep
  - %CPU: 프로세스가 프로세서를 사용한 시간의 백분률
  - %MEM: 프로세스가 사용 중인 물리 RAM의 백분률
  - TIME+: 프로세스가 Core를 사용한 시간
  - COMMAND: 프로세스 시작에 사용한 명령
    
참고. https://gafani.tistory.com/entry/htop-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0


# Action Plan
  - smart 조건
    - Specific: 구체적인
    - Measurable: 측정가능한
    - Attainable: 달성가능한
    - Relevant: 관련있는
    - Time-boxed: ?? 시간 할당인지?
  - 이번주 금요일 12월 8일까지,
    - ProductMetric 공급가 필드 수정 및 검증
    - 과거 데이터 채우기
    - ProductMetric 과거 데이터 검증 완료
  - 다음주 화요일 12월 12얼까지 정산 업무 파악 및 코드 리뷰


## 주간회고
  - 12월 1일: 블렉프라이데이 마지막날!! 무사히 지나가서 다행
  - 12월 4일: 데이터 원천이 다른 경우 어떻게 비교검증해야할지 너무 어렵습니다. ProductMetric 공급가가 변경되어서 조금 좌절했습니다...


  






